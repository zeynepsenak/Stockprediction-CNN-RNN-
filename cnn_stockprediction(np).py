# -*- coding: utf-8 -*-
"""CNN-STOCKPREDICTION(np).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ah7lEEpuEr0FVwVkgHjAv7yxHbfPq3JD
"""

#CNN - Stock Prediction 
import numpy as np
import os
import pandas_datareader as web
import matplotlib.pyplot as plt
import math
from sklearn.preprocessing import MinMaxScaler
from PIL import Image
import cv2
from keras.models import Sequential 
from keras.layers import Conv2D, MaxPooling2D, Dense, Dropout, Flatten, Activation 
plt.style.use('fivethirtyeight')

#x_train-images Folder
dirName = 'xtr_img'
if not os.path.exists(dirName):
    os.mkdir(dirName)
    print("Directory " , dirName ,  " Created ")
else:    
    print("Directory " , dirName ,  " already exists")

#x_test-images Folder
dirName = 'xtest_img'
if not os.path.exists(dirName):
    os.mkdir(dirName)
    print("Directory " , dirName ,  " Created ")
else:    
    print("Directory " , dirName ,  " already exists")

df = web.DataReader('AAPL', data_source='yahoo', start='2004-01-01', end='2020-01-01') 
def loaddata():
    #Visualizieren die Schlusspreisverlauff
    plt.figure(figsize=(16,8))
    plt.title('_Schlusspreisverlauf_')
    plt.plot(df['Close'])
    plt.xlabel('Datum',fontsize=18)
    plt.ylabel('Schlusspreis USD ($)',fontsize=18)
    plt.show()

#x_train (img)
def convert_img(path,xtrainzahl, imgname): #3102-0
  img = Image.fromarray(prex_train[xtrainzahl], 'RGB')
  img.save(path + imgname)
  if(i%100==0):
    print(str(xtrainzahl) + 'ist fertig')

#x_test (img)
def testconvert_img(path, xtestzahl, imgname): #3161-4027
  img = Image.fromarray(prex_test[xtestzahl], 'RGB')
  img.save(path + imgname)
  if(i%100==0):
    print(str(xtestzahl) + 'ist fertig')

loaddata()

data_cl = df.filter(['Close']) #Schluss (Close) Column von Daten : data_cl
clset = data_cl.values #numpy array - data_cl : cl_set
data_op = df.filter(['Open']) #Öffnüng (Open) Column von Daten : data_op
opset = data_op.values #numpy array - data_op : op_set
data_vol = df.filter(['Volume']) #Volumen (Volume) Column von Daten : data_vol
volset = data_vol.values #numpy array - data_vol : vol_set

# len(clset) : 4027

training_data_len = math.ceil( len(clset) *.8) #Train Reiheanzahl

training_data_len

#Skalierung zwischen 0-1 
sc = MinMaxScaler(feature_range=(0, 1)) 
sc_data = sc.fit_transform(clset)

sc_data.shape

train_data = sc_data[0:training_data_len  , : ] #scaliertes trainingsset

#Data teilen: prex_train-y_train, prex_test-y_test 
prex_train=[]
y_train=[]

#121. günün kapanış fiyatını tahmin etmek için önceki 120 günlük veri seti

for i in range(120,len(train_data)):
    prex_train.append(train_data[i-120:i, 0]) 
    y_train.append(train_data[i, 0])

prex_train = np.array(prex_train)

prex_train = np.asarray(prex_train.reshape(3102,12,10))
prex_train.shape

#0-999 train img create:
for i in range(0, 999):
  path = 'xtr_img/'
  xtrainzahl = i
  imgname = 'xtrimg' + str(i) + '.png'
  convert_img(path,xtrainzahl, imgname)

#999-1999 train img create:
for i in range(999, 1999):
  path = 'xtr_img/'
  xtrainzahl = i
  imgname = 'xtrimg' + str(i) + '.png'
  convert_img(path, xtrainzahl, imgname)

#1999-3102 train img create:
for i in range(1999, 3102):
  path = 'xtr_img/'
  xtrainzahl = i
  imgname = 'xtrimg' + str(i) + '.png'
  convert_img(path, xtrainzahl, imgname)

x_train = []
xtrlabels = []
def xTrainProcess(path):
  p = 0
  x = 0
  images = [f for f in os.listdir(path)]
  for iname in images:
    images = str(path + '/' + iname)
    img = cv2.imread(images, cv2.IMREAD_COLOR)
    x_train.append(img)
    xtrlabels.append(x)
    x = x+1
    p = p+1

    if(p%100==0):
      print(str(p) + ' ist fertig')

path = '/content/xtr_img'
xTrainProcess(path)

model = Sequential()
model.add(Conv2D(32, kernel_size=(3, 3),
                 activation='relu',
                 input_shape=(12,10,3)))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(1, activation='softmax'))

model.summary()

#Compile => optimizer:adam loss:ortalama kara hatası
model.compile(optimizer='adam', loss='mean_squared_error')

x_train = np.asarray(x_train)

#Train das Modell
model.fit(x_train, y_train, batch_size=4, epochs=3)

#Test Daten
test_data = sc_data[training_data_len - 120: , : ]
#prex_test und y_test Daten
xi = 0
prex_test = []
y_test =  clset[training_data_len : , : ]
for i in range(120,len(test_data)):
    prex_test.append(test_data[i-120:i,0])    
    xi = xi + 1

prex_test = np.array(prex_test)
prex_test = np.asarray(prex_test.reshape(805,12,10))
prex_test.shape

for i in range(0,xi):
  path='xtest_img/'
  xtestzahl = i 
  imgname = 'xtestimg' + str(i) + '.png'
  testconvert_img(path, xtestzahl, imgname)

x_test = []
xtestlabels = []
def xTestProcess(path):
  p = 0
  x = 0
  images = [f for f in os.listdir(path)]
  for iname in images:
    images = str(path + '/' + iname)
    img = cv2.imread(images, cv2.IMREAD_COLOR)
    x_test.append(img)
    xtestlabels.append(x)
    x = x+1
    p = p+1

    if(p%100==0):
      print(str(p) + ' ist fertig')

path = '/content/xtest_img'
xTestProcess(path)

x_test = np.asarray(x_test)
#Vorhergesagte Preis Werte Model
predictions = model.predict(x_test) 
predictions = sc.inverse_transform(predictions)#Undo Skalierung
x_test.shape

#RMSE Wert - Perfektion des Modells - (Perfekt:0)
rmse=np.sqrt(np.mean(((predictions- y_test)**2)))
rmse

#Plot/Create the data for the graph
train = data_cl[:training_data_len]
valid = data_cl[training_data_len:]
valid['Predictions'] = predictions

#Graph
plt.figure(figsize=(16,8))
plt.title('_Aktienprognose_')
plt.xlabel('Datum', fontsize=18)
plt.ylabel('Schluss Preis USD ($)', fontsize=18)
plt.plot(train['Close'])
plt.plot(valid[['Close', 'Predictions']])
plt.legend(['Train', 'Wert', 'Vorhergesagte Werte'], loc='lower right')
plt.show()

#Schluss Werte und vorhergesagte Werte
valid

